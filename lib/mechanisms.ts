export const mechanisms = [
  {
    id: "mechanism-1",
    title: "1. Maica Currency",
    subtitle: "Algorithmic local money for all on‑site spending.",
    narrative:
      "MaicaToken mints a new supply once every 30 days. The amount of new currency is determined by the growth in the community's service capacity (like new beds or rentable space) and the size of the last rice harvest. This ensures the money supply is tied to real-world value generated by the community.",
    formula: "ΔM = α * max(0, C_t - C_{t-1}) + β * (R_t / 1000)",
    userFlow: [
      "System Oracles (automated feeds) post the latest service capacity (C_t) and rice harvest data (R_t) to the MaicaToken contract.",
      "Every 30 days, the contract checks if it's time for a new emission.",
      "If it is, the contract calculates the new supply (ΔM) using the formula.",
      "The newly calculated Maica tokens are minted and sent to the Rice-Reserve, ready to be used in the ecosystem.",
      "The timer for the next emission is reset for another 30 days.",
    ],
    diagrams: [
      {
        title: "Class Diagram",
        chart: `classDiagram\n     class MaicaToken{\n         +mintToReserve()\n         +burn(from,uint256)\n         +transfer(to,uint256) returns (bool)\n         uint64 nextEmissionBlock\n         uint256 alpha\n         uint256 beta\n         mapping(address=>bool) allowList\n     }\n     class ServiceOracle{\n         +postCapacity(uint256 C_t)\n     }\n     class RiceStockOracle{\n         +postHarvest(uint256 R_t)\n     }\n     MaicaToken <-- ServiceOracle\n     MaicaToken <-- RiceStockOracle`,
      },
      {
        title: "Sequence – Monthly Emission",
        chart: `sequenceDiagram\n     participant SO as ServiceOracle\n     participant RO as RiceStockOracle\n     participant M as MaicaToken\n     SO->>M: postCapacity(C_t)\n     RO->>M: postHarvest(R_t)\n     Note over M: if block ≥ nextEmissionBlock\\nΔM computed by formula\n     M->>M: mintToReserve(ΔM); nextEmissionBlock += 30 days`,
      },
      {
        title: "State Diagram",
        chart: `stateDiagram-v2\n     Dormant --> Live : firstEmission\n     Live --> Live : monthlyEmission\n     Live --> Paused : circuitBreaker\n     Paused --> Live : resume`,
      },
    ],
  },
  {
    id: "mechanism-2",
    title: "2. Rice-Price Oracle",
    subtitle: "Trust‑minimised feed of ¥ per kg.",
    narrative:
      "To ensure the on-chain price of rice is accurate and tamper-proof, a group of independent computer nodes (an MPC federation) fetches price data from multiple public websites. They securely compute the median price, create a cryptographic proof of their work, and post the result to the blockchain.",
    userFlow: [
      "The MPC nodes automatically fetch the latest retail rice prices from predefined websites.",
      "The nodes collaboratively calculate the median price without any single node knowing all the inputs.",
      "They generate a cryptographic proof (TLS-notary proof) to verify the data was fetched correctly.",
      "One of the nodes submits the median price and the proof to the RicePriceOracle smart contract.",
      "The contract verifies the proof. If valid, it updates the on-chain rice price. If not, the transaction fails.",
      "The price is considered 'stale' after a set period (e.g., 48 hours) and needs to be updated again.",
    ],
    diagrams: [
      {
        title: "Class Diagram",
        chart: `classDiagram\n     class RicePriceOracle{\n         +submitPrice(uint128 price, bytes proof)\n         +getPrice() uint128\n         uint64 staleAfter\n         uint128 priceYenPerKg\n         bytes32 lastProof\n     }`,
      },
      {
        title: "Sequence – Price Update",
        chart: `sequenceDiagram\n     participant MPC\n     participant O as RicePriceOracle\n     MPC->>O: submitPrice(price, proofBytes)\n     O->>O: verifyProof(proofBytes)\n     alt valid & timely\n         O->>O: priceYenPerKg = price\n     else\n         O-->>MPC: revert\n     end`,
      },
      {
        title: "State Diagram",
        chart: `stateDiagram-v2\n     Ready --> AwaitingUpdate : when now > lastUpdate+staleAfter\n     AwaitingUpdate --> Ready : successful submitPrice`,
      },
    ],
  },
  {
    id: "mechanism-3",
    title: "3. Rice-Reserve & Swap",
    subtitle: "Determines kg‑per‑Maica and redeems Maica for rice during crises.",
    narrative:
      "The RiceReserve acts as a safety net. In times of crisis, it allows members to exchange their Maica for vouchers for real rice. This redemption is only possible when the Crisis Oracle signals a crisis and there's a sufficient emergency stock (at least 30,000 kg). The exchange rate is calculated dynamically to ensure sustainability.",
    formula: "R(t) = min(γ * (S/M), δ * (P₀/P_t))",
    userFlow: [
      "A Maica holder decides to redeem their tokens for a rice voucher.",
      "The user calls the `redeem` function on the RiceReserve contract, specifying the amount of Maica to swap.",
      "The contract first checks two conditions: Is the `crisisFlag` true? Is the `availableKg` in the rice stock at least 30,000?",
      "If both conditions are met, the contract calculates the current swap ratio R(t) based on total rice stock, total Maica supply, and the current rice price.",
      "The user's Maica tokens are burned (removed from circulation).",
      "A rice voucher for the corresponding amount (maicaAmt * R(t)) is issued to the user.",
      "If conditions are not met, the transaction is reverted, and the user is denied redemption.",
    ],
    diagrams: [
      {
        title: "Class Diagram",
        chart: `classDiagram\n     class RiceReserve{\n         +redeem(uint256 maicaAmt)\n         +issueVoucher(address,uint256 kg)\n         mapping(address=>uint256) riceVoucherKg\n         bool crisisFlag\n     }\n     class MaicaToken{\n         +burn(address,uint256)\n         +totalSupply() uint256\n     }\n     class RiceStockOracle{\n         +availableKg() uint256\n     }\n     class RicePriceOracle{\n         +getPrice() uint128\n     }\n     class CrisisOracle{\n         +crisis() bool\n     }\n     RiceReserve <-- MaicaToken\n     RiceReserve <-- RiceStockOracle\n     RiceReserve <-- RicePriceOracle\n     RiceReserve <-- CrisisOracle`,
      },
      {
        title: "Sequence – Redemption",
        chart: `sequenceDiagram\n     participant H as Holder\n     participant R as RiceReserve\n     H->>R: redeem(maicaAmt)\n     R->>CrisisOracle: crisis()\n     alt crisis && stock >= 30000\n         R->>R: compute R(t)\n         R->>MaicaToken: burn(H, maicaAmt)\n         R-->>H: riceVoucherKg = maicaAmt * R(t)\n     else revert\n         R-->>H: redemption denied\n     end`,
      },
      {
        title: "State Diagram",
        chart: `stateDiagram-v2\n     Standby --> Live : stock >=30 t\n     Live --> Crisis : crisisFlag==true\n     Crisis --> Live : crisis cleared`,
      },
    ],
  },
  {
    id: "mechanism-4",
    title: "4. Usage Market",
    subtitle: "Only approved merchant/utility addresses may receive Maica.",
    narrative:
      "To ensure Maica circulates within the local economy, it has a key restriction: while anyone can send Maica, it can only be received by approved addresses (e.g., the community store, utility providers). This 'allow-list' of recipients is managed by its own members, creating a decentralized governance model.",
    userFlow: [
      "**Spending Maica:** A user sends Maica to a merchant. The MaicaToken contract checks if the recipient's address is on the `allowList`. If yes, the transfer succeeds. If no, it fails.",
      "**Adding a New Merchant:** Two existing members of the `allowList` must agree to add a new merchant. They each sign a message off-chain with their private keys. One of them then submits a transaction to the MaicaToken contract with both signatures. The contract verifies the signatures and, if valid, adds the new merchant's address to the `allowList`.",
      "**Removing a Merchant:** The process is identical to adding, but the signed message indicates a removal.",
    ],
    diagrams: [
      {
        title: "Class Diagram",
        chart: `classDiagram\n     class MaicaToken{\n         +transfer(to,uint256) returns(bool)\n         +proposeAllowChange(addr,bool v, bytes sig1, bytes sig2)\n         mapping(address=>bool) allowList\n         mapping(address=>uint256) nonces\n     }`,
      },
      {
        title: "Sequence – Adding Merchant",
        chart: `sequenceDiagram\n     participant A1 as AllowAddr-1\n     participant A2 as AllowAddr-2\n     participant MT as MaicaToken\n     Note over A1,A2: off-chain EIP-712 signatures on (candidate, add, nonce)\n     A1->>MT: proposeAllowChange(candidate, true, sig1, sig2)\n     alt both sigs valid & signers in allowList\n         MT->>MT: allowList[candidate]=true\n         MT-->>A1: Added event\n     else\n         MT-->>A1: revert\n     end`,
      },
      {
        title: "State Diagram (Recipient)",
        chart: `stateDiagram-v2\n     NotAllowed --> Allowed : added by 2 signatures\n     Allowed --> NotAllowed : removed by 2 signatures`,
      },
    ],
  },
  {
    id: "mechanism-5",
    title: "5. Crisis Oracle",
    subtitle: "Emits a crisis flag by classifying news content.",
    narrative:
      "Similar to the Price Oracle, an MPC cluster monitors a set of reputable online newspapers. It uses an AI model to classify the content of articles, looking for indicators of systemic crisis (e.g., natural disasters, financial collapse). If a majority of the nodes agree that the news indicates a crisis, they push a 'true' flag to the blockchain.",
    userFlow: [
      "The MPC nodes continuously fetch and analyze articles from predefined news sources.",
      "Each node runs a classifier model on the text to vote on whether there is a crisis.",
      "The nodes aggregate their votes. If the majority vote is 'CRISIS', the collective result is `true`.",
      "A node submits the boolean flag (`true` or `false`) and a cryptographic proof to the CrisisOracle contract.",
      "The contract verifies the proof and updates the system-wide `crisis` state.",
      "The RiceReserve contract reads this flag to enable or disable emergency redemptions.",
    ],
    diagrams: [
      {
        title: "Class Diagram",
        chart: `classDiagram\n     class CrisisOracle{\n         +submitFlag(bool crisis, bytes proof)\n         bool crisis\n         uint64 lastUpdate\n     }`,
      },
      {
        title: "Sequence – Heartbeat",
        chart: `sequenceDiagram\n     participant MPC\n     participant CO as CrisisOracle\n     MPC->>CO: submitFlag(crisis, proofBytes)\n     CO->>CO: verifyTLSProof(proofBytes)\n     alt valid\n         CO->>CO: crisis = crisis\n         CO->>RiceReserve: updateCrisisFlag(crisis)\n     else revert\n         CO-->>MPC: invalid\n     end`,
      },
      {
        title: "State Diagram",
        chart: `stateDiagram-v2\n     Normal --> Crisis : crisis==true\n     Crisis --> Normal : crisis==false`,
      },
    ],
  },
  {
    id: "mechanism-6",
    title: "6. Basic Rice-Income",
    subtitle: "Universal annual rice entitlement for every registered member.",
    narrative:
      "To provide a fundamental level of food security, every registered member of the community is entitled to claim vouchers for 60 kg of rice per year. This is a universal right, independent of how much they work or earn, ensuring a basic safety net for all.",
    userFlow: [
      "A registered member decides to claim their annual rice income.",
      "The member calls the `claim()` function on the BasicIncome contract.",
      "The contract checks with the `MemberRegistry` to confirm the user is a valid member.",
      "It then checks that at least 365 days have passed since the user's last claim.",
      "If both checks pass, the BasicIncome contract instructs the RiceReserve to issue a 60kg rice voucher directly to the member.",
      "The BasicIncome contract updates the member's `lastClaim` timestamp to the current time.",
      "If the user is not a member or has claimed within the last year, the transaction fails.",
    ],
    diagrams: [
      {
        title: "Class Diagram",
        chart: `classDiagram\n     class BasicIncome{\n         +claim()\n         mapping(address=>uint64) lastClaim\n         uint256 constant KG_YEAR = 60\n     }\n     class MemberRegistry{\n         +isMember(address) bool\n     }\n     class RiceReserve{\n         +issueVoucher(address,uint256 kg)\n     }\n     BasicIncome --> MemberRegistry\n     BasicIncome --> RiceReserve`,
      },
      {
        title: "Sequence – Annual Claim",
        chart: `sequenceDiagram\n     participant Mem as Member\n     participant BI as BasicIncome\n     participant RR as RiceReserve\n     Mem->>BI: claim()\n     BI->>MemberRegistry: isMember(Mem)\n     alt eligible & ≥365 days since lastClaim\n         BI->>RR: issueVoucher(Mem, 60kg)\n         BI->>BI: lastClaim[Mem] = now\n         RR-->>Mem: riceVoucher(60kg)\n     else\n         BI-->>Mem: revert\n     end`,
      },
      {
        title: "State Diagram",
        chart: `stateDiagram-v2\n     NotClaimed --> Claimed : claim()\n     Claimed --> NotClaimed : 365 days elapsed`,
      },
    ],
  },
]

export const summary = {
  intro:
    "The six mechanisms work in concert to create a resilient, self-regulating, and fair local economy. The design is algorithmic, donation-free, governance-minimal (only self-managed allow-lists), and fully auditable on-chain.",
  points: [
    {
      title: "MaicaToken",
      description: "emits supply monthly, but every payment must land on an allow-listed merchant or utility address.",
    },
    { title: "MPC/TLS Rice-Price Oracle", description: "keeps the on-chain rice price up to date." },
    {
      title: "Crisis Oracle",
      description: "turns the system into crisis mode when a majority of newspaper reports indicate systemic turmoil.",
    },
    {
      title: "RiceReserve",
      description:
        "lets holders swap Maica for rice at a mathematically safe ratio R(t) while the crisis flag is true and at least 30t are in storage.",
    },
    {
      title: "BasicIncome",
      description: "guarantees every member 60 kg of rice per year, regardless of how often they work in the fields.",
    },
  ],
  conclusion:
    "This interconnected system aims to provide stability, food security, and a vibrant local market, all governed by transparent rules rather than discretionary decisions.",
}
